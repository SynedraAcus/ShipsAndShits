CONFLICT CALLS

Conflict must be initialised, then shown, then you may get results. The following is a complete run-through:

    $ init_conflict(u'0З1С1Д')
    # This line initialises everything for a conflict. The only argument is deck-defining line.
    # The syntax is digit-suit letter-digit-suit letter, et cetera et cetera. Usable letters are ЗСДИ
    # As this is a python line, don't forget that dollar sign in the beginning!

    show screen conf
    # This line actually starts conflict. Careful: it's 'show screen', not 'call screen' as in previous version

    "Launching conflict"
    # There must be at least one line of text between showing screen and reading results
    # Conflict screen sets ret variable as follows:
    # Letter F or S for "Failure" or "Success"
    # Then full cyrillic name of the suit that was used in a conflict
    if ret == u'FЗнания':
        "Returned defeat"
        jump failure_knowledge
    #Below are victory variants. The game returns FULL suit name (unicode, don't forget the letter u before the line)
    elif ret == u'SЗнания':
        jump success_knowledge
    elif ret == u'SСила':
        jump success_force

    If you don't need to know which suit was used, you can read only the first letter as follows:
    if ret[0] == u'F':
        "Returned defeat"
        jump failure
    elif ret[0] == u'S':
        "Returned success
        jump success

CARD DEFINITIONS

    More powerful way to design cards is creating them directly, one by one, like this:

    c = Card(u'Д', 2, spendable=False, tooltip='Tooltip', cost = 8)
    player_deck.append(c)

    First two arguments are suit letter and a value. Keyword arguments are:
    spendable (boolean): whether the card is lost after being played
    tooltip (str): card description
    cost (int): cost of this card in gold.


TRADING SCREEN
You currently can add only "Sell card for money"-type actions. The screen is much like previous one.
    $ test_card = Card(u'Д', 10, spendable=True, tooltip='Эта карта была куплена при тестировании магазина')
    # Defining card for sale. First two papameters are suit and value. Spendable is boolean,
    # tooltip is card description; these two can (but should not) be omitted
    #
    $ init_trade(10, test_card)
    #Initialising card's price and card itself
    #
    "Calling shop"
    #Again, at least one line should be present between calling screen and checking for output
    #
    if ret == 'Sold':
        "Покупка совершена"
        jump sold
    elif ret == 'NotSold':
        "Покупка отменена игроком"
        jump cancelled

NEW TRADING SCREEN
New trading screen is called by the following function:

    $ init_trade_screen(stock, accepted_suits=[u'Деньги', u'Знания'])
    The first argument is a list of cards sold in this shop
    The second argument is a list of suits accepted in this shop

Screen is shown and hidden automatically. It currently doesn't place anything into 'ret' variable.
TRAVEL
Unlike previous section, this is guidelines, not strict rules. As in, game won't crash if you violate it,
but I'll personally rip your throat out if you mess label markup.
When the player gets into port from map, renpy jumps to the label named like that port (yankee, node*, poop, etc)
The part right after it should do some port initialisation: check variables and so on.
It should also send a player to correct label within this port. Labels within a port should conform to
variant of hungarian notation described below. Please do not display anything outside of hungarian labels

To leave port, just insert the following line:
    show screen map_screen
    "ANY_RANDOM_LINE"
At least one line should be between calling screen and whatever follows,
for the same reasons as with showing conflict screen.
Make sure you're done with setting variables, editing deck, etc, etc. After this line jump will be called.

RANDOM EVENTS IN NODES
Random event is described by a MapEvent object:
MapEvent(label='node_event1',
         weight=1,
         node_list=['node1', 'node2', 'node3'])

label is the label (in nodes.rpy) where the contents of event are stored. See the next section.
weight is any positive integer. The higher it is -- the more probable is the event. Default is 1, ie the least probable
node_list is the list of node names. Event may happen only at these nodes. If this is not declared, event may
happen anywhere.
Any event will be called no more than once during the game.

RANDOM EVENT SCRIPT
Much like the script of anything else, with one exception. Make sure to call the

$leave_node()

function in the end, otherwise the map will not be called correctly. Please also call nvl clear at the start of each event

HUNGARIAN NOTATION
Please keep naming consistent. All label and variable names should start with port name,
followed by underscore, followed by variable name. If variable has to do with some specific plot
within a port, plot name should be included as well.

For example, labels related to node1 should be called:
node1_start
node1_waves
node1_wind
(the following 3 are about an encounter with the Devil)
node1_devil_ship
node1_devil_sell
node1_devil_refuse
(the following probably calls map screen)
node1_final

Labels and variables related to universal events that may happen at any node should start with 'node_':
node_rock_me_mama
node_event1
node_event2

If the variable has nothing to do with any particular port,
it should start with gl_ (short for 'global'):
gl_office_interest = 0
gl_ill = True

This doesn't apply to global variables like player_deck, Map_point objects and others.
As a rule of thumb, if you create variable, make it as it says above. If it was created
before you, let it be.